% Generated by roxygen2 (4.0.2): do not edit by hand
\name{which.orders}
\alias{which.orders}
\title{Utilities for detecting the orders of date strings}
\usage{
which.orders(x, orders = all.orders,
  autostart = getOption("date.reader.autostart"),
  nErrors = getOption("date.reader.nErrors"), force = FALSE, ...)
}
\arguments{
\item{x}{character; values to convert to a POSIX date}

\item{orders}{character; orders to choose from}

\item{autostart}{integer; number of strings to check before deciding
the orders}

\item{nErrors}{numeric; A non-negative number:
if >= 1, the number of unparsable strings to allow
if <  1, the fraction of values that are allowed to be unparsable before
giving up.}

\item{force}{logical; TRUE means try to interpret as date, even if number
of strings is less than autostart. This is only relevant for the all-digits
format: 20141222; we don't want to consider this a date unless there are
sufficient data, or if force == TRUE.}

\item{...}{list; extra parameters (unused)}
}
\value{
character, name for the date orders, e.g. mdy, ymd_hm, etc.
}
\description{
Utilities for detecting the orders of date strings

If the number of unparseable strings exceeds nErrors, return NA,
which means that the strings are either not dates, or not a consistent
format.
}
\examples{
x <- c("January 11, 2014", "February 15, 1958", "March 3, 1969")
  which.orders(x, autostart=3, nErrors=1)
}
\seealso{
\code{\link[base]{as.POSIXct}} \cr
  \code{\link[lubridate]{guess_formats}} \cr
}

