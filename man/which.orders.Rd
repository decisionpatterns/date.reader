% Generated by roxygen2 (4.1.0.9001): do not edit by hand
% Please edit documentation in R/which.orders.R
\name{which.orders}
\alias{which.orders}
\title{which.orders}
\usage{
which.orders(x, orders = get_option(date.reader$orders, all.orders),
  autostart = get_option(date.reader$autostart, 30),
  nErrors = get_option(date.reader$nErrors, 0), force = FALSE, ...)
}
\arguments{
\item{x}{vector; values from which orders will be determined.}

\item{orders}{character; allowable orders that are used.}

\item{autostart}{integer; number of elements randomly sampled from of
\code{x} to check to determine the possible orders of \code{x}.}

\item{nErrors}{numeric; A non-negative number:
if >= 1, the number of unparsable strings to allow
if < 1, the fraction of values that are allowed to be unparsable before
giving up. See \strong{Details}.}

\item{force}{logical; if \code{TRUE} interpret as date, even if number
of strings is less than autostart. This is only relevant for the all-digits
format: 20141222; we don't want to consider this a date unless there are
sufficient data, or if force == TRUE.}

\item{...}{list; extra parameters (unused)}
}
\value{
character, name for the date orders, e.g. mdy, ymd_hm, etc.
}
\description{
detecting the date 'orders' of character vector
}
\details{
\code{which.orders} returns the possible orders of \code{x}.


If the number of unparseable strings exceeds nErrors, return NA,
which means that the strings are either not dates, or not a consistent
format.
}
\examples{
# Same order, same format
  x <- c("January 11, 2014", "February 15, 1958", "March 3, 1969")
  which.orders(x)

  # Same order, different formats
  x <- c("January 11, 2014", "February 15, 1958", "3/3/1969")
  which.orders(x, autostart=3, nErrors=1)

  which.orders( 20150101:20150131 )
  which.orders( 20150101:20150131, autostart = 50  )  # ??
  which.orders( 2015001:2015365 )   # NA
}
\seealso{
\code{\link[base]{as.POSIXct}} \cr
  \code{\link[lubridate]{guess_formats}} \cr
}

