% Generated by roxygen2 (4.1.0.9001): do not edit by hand
% Please edit documentation in R/which.orders.R
\name{which.orders}
\alias{which.orders}
\title{which.orders}
\usage{
which.orders(x, orders = all.orders,
  autostart = get_option(date.reader$autostart, 30),
  nErrors = get_option(date.reader$nErrors, 0), force = FALSE, ...)
}
\arguments{
\item{x}{character; values to convert to a POSIX date}

\item{orders}{character; orders that can be returned}

\item{autostart}{integer; number of elements of \code{x} to check
to determine the orders of \code{x}}

\item{nErrors}{numeric; A non-negative number:
if >= 1, the number of unparsable strings to allow
if <  1, the fraction of values that are allowed to be unparsable before
giving up.}

\item{force}{logical; TRUE means try to interpret as date, even if number
of strings is less than autostart. This is only relevant for the all-digits
format: 20141222; we don't want to consider this a date unless there are
sufficient data, or if force == TRUE.}

\item{...}{list; extra parameters (unused)}
}
\value{
character, name for the date orders, e.g. mdy, ymd_hm, etc.
}
\description{
If the number of unparseable strings exceeds nErrors, return NA,
which means that the strings are either not dates, or not a consistent
format.
}
\details{
detecting the date 'orders' of character vector
}
\examples{
# Same order, same format
  x <- c("January 11, 2014", "February 15, 1958", "March 3, 1969")
  which.orders(x)

  # Same order, different formats
  x <- c("January 11, 2014", "February 15, 1958", "3/3/1969")
  which.orders(x, autostart=3, nErrors=1)
}
\seealso{
\code{\link[base]{as.POSIXct}} \cr
  \code{\link[lubridate]{guess_formats}} \cr
}

